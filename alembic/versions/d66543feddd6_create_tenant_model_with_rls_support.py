"""Create tenant model with RLS support

Revision ID: d66543feddd6
Revises: 
Create Date: 2025-08-07 23:27:27.065991

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision: str = 'd66543feddd6'
down_revision: Union[str, None] = None
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # Create the tenant_type enum first (only if it doesn't exist)
    op.execute("""
    DO $$
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'tenant_type') THEN
            CREATE TYPE tenant_type AS ENUM ('parent', 'subsidiary');
        END IF;
    END $$;
    """)
    
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('tenants',
    sa.Column('tenant_id', sa.UUID(), nullable=False, comment='Unique identifier for the tenant'),
    sa.Column('name', sa.String(length=200), nullable=False, comment='Human-readable tenant name, unique within parent hierarchy'),
    sa.Column('parent_tenant_id', sa.UUID(), nullable=True, comment='Reference to parent tenant for subsidiaries'),
    sa.Column('tenant_type', sa.String(20), nullable=False, comment='Type of tenant: parent (top-level) or subsidiary'),
    sa.Column('tenant_metadata', postgresql.JSONB(astext_type=sa.Text()), nullable=True, comment='Additional JSON metadata for flexible storage'),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=False, comment='Record creation timestamp'),
    sa.Column('updated_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=False, comment='Record last update timestamp'),
    sa.CheckConstraint("(tenant_type = 'parent' AND parent_tenant_id IS NULL) OR (tenant_type = 'subsidiary' AND parent_tenant_id IS NOT NULL)", name='ck_tenant_parent_logic'),
    sa.CheckConstraint("trim(name) != ''", name='ck_tenant_name_not_empty'),
    sa.CheckConstraint('tenant_id != parent_tenant_id', name='ck_tenant_no_self_reference'),
    sa.ForeignKeyConstraint(['parent_tenant_id'], ['tenants.tenant_id'], ondelete='RESTRICT'),
    sa.PrimaryKeyConstraint('tenant_id')
    )
    
    # Now alter the column to use the enum type
    op.execute("ALTER TABLE tenants ALTER COLUMN tenant_type TYPE tenant_type USING tenant_type::tenant_type;")
    op.create_index('ix_tenant_metadata', 'tenants', ['tenant_metadata'], unique=False, postgresql_using='gin')
    op.create_index('ix_tenant_name_lower', 'tenants', [sa.literal_column('lower(name)')], unique=False)
    op.create_index('ix_tenant_parent_id', 'tenants', ['parent_tenant_id'], unique=False)
    op.create_index('ix_tenant_type', 'tenants', ['tenant_type'], unique=False)
    op.create_index('uq_tenant_name_per_parent', 'tenants', ['name', 'parent_tenant_id'], unique=True)
    # ### end Alembic commands ###

    # Enable RLS and create supporting functions
    op.execute("ALTER TABLE tenants ENABLE ROW LEVEL SECURITY;")
    
    # Create function to get current tenant context from session
    op.execute("""
    CREATE OR REPLACE FUNCTION current_tenant_id()
    RETURNS UUID AS $$
    BEGIN
        -- Get tenant_id from session variable set by application
        RETURN current_setting('app.current_tenant_id', true)::UUID;
    EXCEPTION
        WHEN OTHERS THEN
            -- Return NULL if not set or invalid
            RETURN NULL;
    END;
    $$ LANGUAGE plpgsql STABLE;
    """)
    
    # Create function to check if user can access tenant data
    op.execute("""
    CREATE OR REPLACE FUNCTION can_access_tenant(target_tenant_id UUID)
    RETURNS BOOLEAN AS $$
    DECLARE
        session_tenant_id UUID;
        target_parent_id UUID;
    BEGIN
        -- Get current session tenant
        session_tenant_id := current_tenant_id();
        
        -- If no session tenant set, deny access
        IF session_tenant_id IS NULL THEN
            RETURN FALSE;
        END IF;
        
        -- If accessing own tenant, allow
        IF session_tenant_id = target_tenant_id THEN
            RETURN TRUE;
        END IF;
        
        -- Check if session tenant is parent of target tenant
        SELECT parent_tenant_id INTO target_parent_id 
        FROM tenants 
        WHERE tenant_id = target_tenant_id;
        
        IF target_parent_id = session_tenant_id THEN
            RETURN TRUE;
        END IF;
        
        -- Deny access (siblings cannot see each other)
        RETURN FALSE;
    END;
    $$ LANGUAGE plpgsql STABLE;
    """)
    
    # Create RLS policies
    op.execute("""
    CREATE POLICY tenant_select_policy ON tenants
        FOR SELECT
        USING (can_access_tenant(tenant_id));
    """)
    
    op.execute("""
    CREATE POLICY tenant_insert_policy ON tenants
        FOR INSERT
        WITH CHECK (
            -- Allow creation if no session tenant (bootstrap case)
            current_tenant_id() IS NULL OR
            
            -- Allow parent tenant creation
            (tenant_type = 'parent' AND parent_tenant_id IS NULL) OR
            
            -- Allow subsidiary creation under current tenant
            (tenant_type = 'subsidiary' AND parent_tenant_id = current_tenant_id()) OR
            
            -- Allow subsidiary creation if current tenant is the parent
            (tenant_type = 'subsidiary' AND 
             parent_tenant_id IS NOT NULL AND 
             can_access_tenant(parent_tenant_id))
        );
    """)
    
    op.execute("""
    CREATE POLICY tenant_update_policy ON tenants
        FOR UPDATE
        USING (can_access_tenant(tenant_id))
        WITH CHECK (
            -- Ensure updated record still complies with access rules
            can_access_tenant(tenant_id)
        );
    """)
    
    op.execute("""
    CREATE POLICY tenant_delete_policy ON tenants
        FOR DELETE
        USING (
            can_access_tenant(tenant_id) AND
            
            -- Additional check: cannot delete parent with active subsidiaries
            NOT EXISTS (
                SELECT 1 FROM tenants child 
                WHERE child.parent_tenant_id = tenants.tenant_id
            )
        );
    """)
    
    # Create utility functions for tenant context management
    op.execute("""
    CREATE OR REPLACE FUNCTION set_tenant_context(tenant_uuid UUID)
    RETURNS VOID AS $$
    BEGIN
        -- Validate that the tenant exists
        IF NOT EXISTS (SELECT 1 FROM tenants WHERE tenant_id = tenant_uuid) THEN
            RAISE EXCEPTION 'Tenant % does not exist', tenant_uuid;
        END IF;
        
        -- Set the session variable
        PERFORM set_config('app.current_tenant_id', tenant_uuid::text, true);
    END;
    $$ LANGUAGE plpgsql;
    """)
    
    op.execute("""
    CREATE OR REPLACE FUNCTION clear_tenant_context()
    RETURNS VOID AS $$
    BEGIN
        PERFORM set_config('app.current_tenant_id', '', true);
    END;
    $$ LANGUAGE plpgsql;
    """)
    
    # Create function to get tenant hierarchy (for debugging/admin purposes)
    op.execute("""
    CREATE OR REPLACE FUNCTION get_tenant_hierarchy(root_tenant_id UUID)
    RETURNS TABLE (
        tenant_id UUID,
        name VARCHAR(200),
        tenant_type tenant_type,
        level INTEGER,
        path TEXT
    ) AS $$
    WITH RECURSIVE tenant_tree AS (
        -- Base case: start with the root tenant
        SELECT 
            t.tenant_id,
            t.name,
            t.tenant_type,
            1 as level,
            t.name::TEXT as path
        FROM tenants t
        WHERE t.tenant_id = root_tenant_id
        
        UNION ALL
        
        -- Recursive case: get children
        SELECT 
            t.tenant_id,
            t.name,
            t.tenant_type,
            tt.level + 1,
            tt.path || ' -> ' || t.name
        FROM tenants t
        JOIN tenant_tree tt ON t.parent_tenant_id = tt.tenant_id
    )
    SELECT * FROM tenant_tree ORDER BY level, name;
    $$ LANGUAGE sql;
    """)
    
    # Add comments for RLS documentation
    op.execute("COMMENT ON FUNCTION current_tenant_id() IS 'Gets the current tenant context from session variable';")
    op.execute("COMMENT ON FUNCTION can_access_tenant(UUID) IS 'Checks if current session can access specific tenant data';")
    op.execute("COMMENT ON FUNCTION set_tenant_context(UUID) IS 'Sets tenant context for current session';")
    op.execute("COMMENT ON FUNCTION clear_tenant_context() IS 'Clears tenant context from current session';")
    op.execute("COMMENT ON FUNCTION get_tenant_hierarchy(UUID) IS 'Returns hierarchical view of tenant and its subsidiaries';")


def downgrade() -> None:
    # Drop RLS policies first
    op.execute("DROP POLICY IF EXISTS tenant_delete_policy ON tenants;")
    op.execute("DROP POLICY IF EXISTS tenant_update_policy ON tenants;") 
    op.execute("DROP POLICY IF EXISTS tenant_insert_policy ON tenants;")
    op.execute("DROP POLICY IF EXISTS tenant_select_policy ON tenants;")
    
    # Drop functions
    op.execute("DROP FUNCTION IF EXISTS get_tenant_hierarchy(UUID);")
    op.execute("DROP FUNCTION IF EXISTS clear_tenant_context();")
    op.execute("DROP FUNCTION IF EXISTS set_tenant_context(UUID);")
    op.execute("DROP FUNCTION IF EXISTS can_access_tenant(UUID);")
    op.execute("DROP FUNCTION IF EXISTS current_tenant_id();")
    
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_index('uq_tenant_name_per_parent', table_name='tenants')
    op.drop_index('ix_tenant_type', table_name='tenants')
    op.drop_index('ix_tenant_parent_id', table_name='tenants')
    op.drop_index('ix_tenant_name_lower', table_name='tenants')
    op.drop_index('ix_tenant_metadata', table_name='tenants', postgresql_using='gin')
    op.drop_table('tenants')
    # ### end Alembic commands ###
    
    # Drop the tenant_type enum after dropping the table (only if it exists)
    op.execute("DROP TYPE IF EXISTS tenant_type;")